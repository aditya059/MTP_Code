#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <gmp.h>
#include "paillier.h"

#define d 1000
#define C 2
#define epsilon 2
#define eta d + 1 + C + epsilon
paillier_plaintext_t *query[d];
paillier_ciphertext_t *encrypted_query[d];
mpz_t M[eta][eta];
mpz_t Rq[C];
paillier_ciphertext_t *Aq[eta];
paillier_plaintext_t *decrypted_query[eta];

int main()
{
    unsigned long seed;

    // initilze the state object for the random generator functions
    gmp_randstate_t state;
    // initialize state for a Mersenne Twister algorithm. This algorithm is fast and has good randomness properties.
    gmp_randinit_mt(state);
    // create the generator seed for the random engine to reference
    gmp_randseed_ui(state, seed);

    void *buf = malloc(128);
    void (*get_rand)(void *, int) = paillier_get_rand_devurandom;
    get_rand(buf, 128);

    // GMP Variables
    mpz_t maxRange, phi, betaQ, gcd;
    mpz_init_set_si(maxRange, 999999);
    mpz_init(phi);
    mpz_init(betaQ);
    mpz_init(gcd);
    mpz_urandomm(betaQ, state, maxRange);
    gmp_printf("%s = %Zd\n", "Beta generated by DO = ", betaQ);

    //--------------------------------------------------------------------------------------------------------//
    // Query User's Work
    // Paillier Key Generation
    paillier_pubkey_t *PK;
    paillier_prvkey_t *SK;
    paillier_keygen(1024, &PK, &SK, get_rand);

    for (int i = 0; i < d; i++)
    {
        query[i] = (paillier_plaintext_t *)malloc(sizeof(paillier_plaintext_t));
        mpz_init(query[i]->m);
        mpz_urandomm(query[i]->m, state, maxRange);
        encrypted_query[i] = paillier_enc(NULL, PK, query[i], get_rand);
        // gmp_printf("%s = %Zd\n", "PlainText", query[i]->m);
        // gmp_printf("%s = %Zd\n", "CipherText", encrypted_query[i]->c);
    }

    //--------------------------------------------------------------------------------------------------------//
    // Data Owner's Work
    // Input
    // pi = TODO

    for (int i = 0; i < C; i++)
    {
        mpz_init(Rq[i]);
        mpz_urandomm(Rq[i], state, maxRange);
    }

    for (int i = 0; i < eta; i++)
    {
        for (int j = 0; j < eta; j++)
        {
            mpz_init(M[i][j]);
            mpz_urandomm(M[i][j], state, maxRange);
        }
    }

    clock_t begin = clock();

    paillier_plaintext_t *zero = (paillier_plaintext_t *)malloc(sizeof(paillier_plaintext_t));
    mpz_init_set_si(zero->m, 0);
    paillier_plaintext_t *plainPhi = (paillier_plaintext_t *)malloc(sizeof(paillier_plaintext_t));
    mpz_init(plainPhi->m);
    paillier_ciphertext_t *temp = (paillier_ciphertext_t *)malloc(sizeof(paillier_ciphertext_t));
    mpz_init(temp->c);
    paillier_ciphertext_t *encryptedPhi;

    for (int i = 0; i < eta; i++)
    {
        Aq[i] = paillier_enc(NULL, PK, zero, get_rand);
        for (int j = 0; j < eta; j++)
        {
            int t = j;
            mpz_mul(phi, M[i][j], betaQ);
            if (t < d)
            {
                mpz_set(plainPhi->m, phi);
                paillier_exp(PK, temp, encrypted_query[t], plainPhi);
                paillier_mul(PK, Aq[i], Aq[i], temp);
            }
            else if (t == d)
            {
                mpz_set(plainPhi->m, phi);
                encryptedPhi = paillier_enc(NULL, PK, plainPhi, get_rand);
                paillier_mul(PK, Aq[i], Aq[i], encryptedPhi);
                paillier_freeciphertext(encryptedPhi);
            }
            else if (t <= d + C)
            {
                mpz_mul(phi, phi, Rq[t - d - 1]);
                mpz_set(plainPhi->m, phi);
                encryptedPhi = paillier_enc(NULL, PK, plainPhi, get_rand);
                paillier_mul(PK, Aq[i], Aq[i], encryptedPhi);
                paillier_freeciphertext(encryptedPhi);
            }
        }
    }

    clock_t end = clock();
    double time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
    printf("Paillier Encryption time at DO = %f\n", time_spent);

    begin = clock();

    for (int i = 0; i < eta; i++)
    {
        decrypted_query[i] = paillier_dec(NULL, PK, SK, Aq[i]);
        // gmp_printf("%s = %Zd\n", "DecryptedQuery", decrypted_query[i]->m);
    }
    end = clock();
    time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
    printf("Paillier Decryption time at QU = %f\n", time_spent);

    mpz_set(gcd, decrypted_query[0]->m);
    for (int i = 1; i < eta; i++)
    {
        mpz_gcd(gcd, gcd, decrypted_query[i]->m);
    }
    gmp_printf("%s = %Zd\n", "Calculated Beta at QU = ", gcd);

    // *********************** GARBAGE COLLECTION *********************** //
    // empty the memory location for the random generator state
    gmp_randclear(state);
    // clear the memory locations for the variables used to avoid leaks
    mpz_clear(maxRange);
    mpz_clear(phi);
    mpz_clear(betaQ);
    mpz_clear(gcd);

    paillier_freepubkey(PK);
    paillier_freeprvkey(SK);
    paillier_freeplaintext(zero);
    paillier_freeplaintext(plainPhi);
    paillier_freeciphertext(temp);

    for (int i = 0; i < d; i++)
    {
        paillier_freeplaintext(query[i]);
        paillier_freeciphertext(encrypted_query[i]);
    }
    for (int i = 0; i < eta; i++)
    {
        paillier_freeplaintext(decrypted_query[i]);
        paillier_freeciphertext(Aq[i]);
    }
    for (int i = 0; i < C; i++)
    {
        mpz_clear(Rq[i]);
    }
    for (int i = 0; i < eta; i++)
    {
        for (int j = 0; j < eta; j++)
        {
            mpz_clear(M[i][j]);
        }
    }

    free(buf);
    return 0;
}