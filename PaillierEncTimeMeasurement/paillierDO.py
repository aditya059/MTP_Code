from phe import paillier
import numpy as np
from numpy import linalg as LA
from numpy.linalg import inv
import random
import math
import time

d = 100
maxRange = 10000000

#--------------------------------------------------------------------------#
# Query User's Work
public_key, private_key = paillier.generate_paillier_keypair()
query = []
for i in range(0, d):
    query.append(random.randint(0, maxRange))

encrypted_query = [public_key.encrypt(x) for x in query]
#print("Query = ", query)

#--------------------------------------------------------------------------#
# Data Owner's Work
c = 2
epsilon = 2
eta = d + 1 + c + epsilon
# Input
# pi = TODO
betaQ = random.randint(0, 1000)
print("Beta generated by DO = ", betaQ)
Rq = np.random.randint(0, maxRange, size=c)

M = np.random.randint(0, 100, size=(eta, eta))
while (np.linalg.det(M) == 0):
    M = np.random.randint(0, 100, size=(eta, eta))
M_inverse = inv(M)


start_time = time.time()
Aq = []
encrypted_zero = public_key.encrypt(0)
for i in range(0, eta):
    Aq.append(encrypted_zero)
    for j in range(0, eta):
        t = j
        phi = int(M[i][j]) * betaQ
        if t < d:
            Aq[i] = Aq[i] + (encrypted_query[t] * phi)
        elif t == d:
            Aq[i] = Aq[i] + (public_key.encrypt(phi))
        elif t <= d + c:
            phi = phi * int(Rq[t - d - 1])
            Aq[i] = Aq[i] + (public_key.encrypt(phi))

print("Paillier Encryption time at DO = ", time.time() - start_time)

start_time = time.time()
decrypted_query = [private_key.decrypt(x) for x in Aq]
# print(decrypted_query)
print("Paillier Decryption time at QU = ", time.time() - start_time)

print("Calculated Beta at QU = ", math.gcd(*decrypted_query))
